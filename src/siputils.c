/**
 * Copyright (C) 2009  Alex Revetchi
 *
 * Siplexd is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <stdlib.h>
#include <arpa/inet.h>
#include <osip2/osip.h>
#include <osipparser2/headers/osip_via.h>
#include <osipparser2/osip_md5.h>
#include <limits.h>
#include <time.h>
#include "sock.h"
#include "siputils.h"
#include "logger.h"
#include "sipdigest.h"

/*
 7.2.3 Matching Requests to Server Transactions

   When a request is received from the network by the server, it has to
   be matched to an existing transaction.  This is accomplished in the
   following manner.

   The branch parameter in the topmost Via header field of the request
   is examined.  If it is present and begins with the magic cookie
   "z9hG4bK", the request was generated by a client transaction
   compliant to this specification.  Therefore, the branch parameter
   will be unique across all transactions sent by that client.  The
   request matches a transaction if:

      1. the branch parameter in the request is equal to the one in the
         top Via header field of the request that created the
         transaction, and

      2. the sent-by value in the top Via of the request is equal to the
         one in the request that created the transaction, and

      3. the method of the request matches the one that created the
         transaction, except for ACK, where the method of the request
         that created the transaction is INVITE.

   This matching rule applies to both INVITE and non-INVITE transactions
   alike.

      The sent-by value is used as part of the matching process because
      there could be accidental or malicious duplication of branch
      parameters from different clients.

   If the branch parameter in the top Via header field is not present,
   or does not contain the magic cookie, the following procedures are
   used.  These exist to handle backwards compatibility with RFC 2543
   compliant implementations.

   The INVITE request matches a transaction if the Request-URI, To tag,
   From tag, Call-ID, CSeq, and top Via header field match those of the
   INVITE request which created the transaction.  In this case, the
   INVITE is a retransmission of the original one that created the
   transaction.  The ACK request matches a transaction if the Request-
   URI, From tag, Call-ID, CSeq number (not the method), and top Via
   header field match those of the INVITE request which created the
   transaction, and the To tag of the ACK matches the To tag of the
   response sent by the server transaction.  Matching is done based on
   the matching rules defined for each of those header fields.
   Inclusion of the tag in the To header field in the ACK matching
   process helps disambiguate ACK for 2xx from ACK for other responses
   at a proxy, which may have forwarded both responses (This can occur
   in unusual conditions.  Specifically, when a proxy forked a request,
   and then crashes, the responses may be delivered to another proxy,
   which might end up forwarding multiple responses upstream).  An ACK
   request that matches an INVITE transaction matched by a previous ACK
   is considered a retransmission of that previous ACK.
 */

static const char mcookie[]   ="z9hG4bK";

int get_port_from_str(const char* s_port)
{
    int port = 5060;
    if (NULL != s_port)
    {
        const int p = atoi (s_port);
        if (1 < p && p < INT_MAX) port = p;
    }
    return port;
}


int is_proxy_address(char* host, char* port)
{
    __tri(is_proxy_address);

    struct in_addr addr;
    if (RC_OK == get_host_addr(host, &addr))
    {
        const int port = get_port_from_str (port);
        static const size_t sz = sizeof(struct in_addr);
        
        __tre(return) (port == get_out_port() && !memcmp (&addr, get_out_addr(), sz)) ||
                      (port == get_in_port()  && !memcmp (&addr, get_in_addr(),  sz));
    }
    
    __tre(return) 0;
}

void update_max_fowards(osip_message_t* sipmsg)
{
    __tri(update_max_fowards);

    osip_header_t *maxfwd = NULL;
    char fwdStr[16];

    int ret = osip_message_get_max_forwards (sipmsg, 0, &maxfwd);

    int fwd = ((!ret && maxfwd && maxfwd->hvalue)? atoi(maxfwd->hvalue):70+1)-1;

    snprintf (fwdStr, sizeof(fwdStr), "%i", fwd);

    if (maxfwd->hvalue) osip_free(maxfwd->hvalue);
    maxfwd->hvalue = osip_strdup(fwdStr);

    __tre(return);
}

osip_message_t* init_sip_msg_from_src (const osip_message_t *sipmsg, const int code)
{
    __tri(init_sip_msg_from_src);

    if (sipmsg->to && sipmsg->from)
    {
       osip_message_t* sipgen;
       osip_message_init (&sipgen);

       if (sipgen)
       {
           sipgen->message = NULL;
           osip_message_set_version (sipgen, osip_strdup ("SIP/2.0"));
           osip_message_set_status_code (sipgen, code);
           osip_message_set_reason_phrase (sipgen,
                                   osip_strdup(osip_message_get_reason (code)));


           if (code == SIP_MOVED_TEMPORARILY)
           {
               char contact[100];
                snprintf (contact, sizeof(contact), "<sip:%s@%s:%s>",
                          sipmsg->to->url->username, "sip.voipcheap.com", "5060");

                osip_message_set_contact(sipgen, contact);

                osip_to_clone   (sipmsg->to,   &sipgen->from);
                osip_from_clone (sipmsg->from, &sipgen->to);

           }
           else
           {
               /*include 1st contact header  if 3xx*/
               if (code < SIP_BAD_REQUEST && (SIP_OK == code || code >= SIP_MULTIPLE_CHOICES) )
               {
                   osip_contact_t* src_contact = NULL;
                   osip_message_get_contact(sipmsg, 0, &src_contact);

                   if (src_contact)
                   {
                       osip_contact_t* res_contact = NULL;
                       osip_contact_clone (src_contact, &res_contact);

                       if (res_contact)
                       {
                           osip_list_add(&(sipgen->contacts),res_contact,0);
                       }
                   }
               }

               osip_to_clone   (sipmsg->to,   &sipgen->to);
               osip_from_clone (sipmsg->from, &sipgen->from);
           }

           /* via headers */
           int pos = 0;
           while (!osip_list_eol (&sipmsg->vias, pos))
           {
               osip_via_t*via = (osip_via_t*)osip_list_get (&sipmsg->vias, pos);
               char *tmp;
               osip_via_to_str (via, &tmp);
               osip_message_set_via (sipgen, tmp);
               osip_free (tmp);
               pos++;
           }

           osip_call_id_clone (sipmsg->call_id, &sipgen->call_id);
           osip_cseq_clone    (sipmsg->cseq,    &sipgen->cseq);
           __tre(return) sipgen;
       }
   }
      
   __tre(return) NULL;
}


void gen_and_send_sip_response(const osip_message_t *sipsrc, const int code)
{
    __tri(gen_and_send_sip_response);

    sip_msg_str_t sms;
    /* create the response template */
    sms.osip_msg = init_sip_msg_from_src (sipsrc, code);

    if (sms.osip_msg)
    {        
        osip_via_t *via = NULL;
        osip_message_get_via (sms.osip_msg, 0, &via);
   
        if (via)
        {
            struct in_addr addr;            
            if (RC_OK == get_host_addr(via->host, &addr))
            {
                if (!osip_message_to_str(sms.osip_msg, &sms.buffer, &sms.bufferlen))
                {
                    sms.msgsize = sms.bufferlen;
                    sms.rcvr_port = get_port_from_str(via->port);
                    
                    memcpy (&sms.rcvr_addr, &addr, sizeof (struct in_addr));
                    
                    sip_send (&sms);
                    osip_free(sms.buffer);
                }
            }
        }

        osip_message_free(sms.osip_msg);
    }

    __tre(return);
}

int add_proxy_via (sip_msg_str_t* sms)
{
    __tri(add_proxy_via);

    char branchId[128];
    char urlStr[128];
    char viaAddrStr[INET_ADDRSTRLEN];
    int port = -1;
    struct in_addr* via_addr = NULL;
    int failOnError = 0;

    switch (sms->direction)
    {
        case DIRECTION_OUT:
            port     = get_out_port();
            via_addr = get_out_addr();
            failOnError = 1;
            break;
        case DIRECTION_IN:
            port     = get_in_port();
            via_addr = get_in_addr();
            break;
        default:
            logERROR("Could not determine message direction!");
            __tre(return) RC_ERR;
    }

    if (!inet_ntop(AF_INET, via_addr, viaAddrStr, sizeof (viaAddrStr)))
    {
        __tre(return) (failOnError)? RC_ERR: RC_OK;
    }

    get_stateles_branch_id (sms->osip_msg, branchId);

    sprintf (urlStr, "SIP/2.0/UDP %s:%i;branch=%s",
             viaAddrStr, port,
             branchId);

    osip_via_t *via;
    if (osip_via_init(&via) ||
        osip_via_parse(via, urlStr)) return RC_ERR;

    osip_list_add (&sms->osip_msg->vias, via, 0);

    __tre(return) RC_OK;
}

int remove_proxy_via(osip_message_t* sipmsg)
{
    __tri(remove_proxy_via);
    osip_via_t* via = osip_list_get (&sipmsg->vias, 0);

    if (0 != via && is_proxy_address(via->host, via->port))
    {
        osip_list_remove(&sipmsg->vias, 0);
        osip_via_free (via);
        __tre(return) RC_OK;
    }
 
    __tre(return) (via)? RC_ERR: RC_OK;
}

int calculate_next_hop(sip_msg_str_t* sms)
{
    __tri(calculate_next_hop);

    osip_message_t* osip_msg = sms->osip_msg;
    const char* host = NULL;
    const char* s_port = NULL;

    while (!osip_list_eol(&osip_msg->routes, 0))
    {
        /*  16.4 Route Information Preprocessing
             If the first value in the Route header field indicates this proxy,
             the proxy MUST remove that value from the request. */
        const osip_route_t* route = (osip_route_t*)osip_list_get(&osip_msg->routes, 0);
        if (route->url && route->url->host)
        {
            if (!is_proxy_address(route->url->host, route->url->port))
            {
               host   = route->url->host;
               s_port = route->url->port;
               break;
            }
        }
        osip_list_remove (&osip_msg->routes, 0);
        osip_via_free (route);
    }

    if (!host)
    {
        if (MSG_IS_REQUEST(osip_msg))
        {
            osip_uri_t* uri = osip_message_get_uri(osip_msg);
            host = uri->host;        
            s_port = uri->port;
        }
        else
        {
            osip_via_t* via = (osip_via_t*)osip_list_get (&osip_msg->vias, 0);

            if (via)
            {
                host = via->host;
                s_port = via->port;
            }
        }
    }

    if (host && RC_OK == get_host_addr(host, &sms->rcvr_addr))
    {
        sms->rcvr_port = get_port_from_str(s_port);
    }
    else
    {
        logERROR("Could not calculate next hop.");
        __tre(return) RC_ERR;
    }

    __tre(return) RC_OK;
}


int  get_stateles_branch_id (osip_message_t* sipmsg, char* branch_id)
{
    __tri(get_stateles_branch_id);

    //8.1.1.7 Via    
    HASHHEX hashstring;

    hashstring[0]='\0';

    /*
     * Examine topmost via and look for a magic cookie.
     * If it is there, I use THIS branch parameter as input for
     * our hash calculation
     */
    osip_via_t* via = osip_list_get (&sipmsg->vias, 0);
    if (NULL == via)
    {
       logERROR("SIP message does not contain any via header.");
       __tre(return) RC_ERR;
    }

    osip_uri_param_t* param = NULL;
    osip_via_param_get_byname(via, "branch", &param);

    if (param && param->gvalue)
    {
       if (!strcmp(param->gvalue, mcookie))
       {
          /* calculate MD5 hash */
          osip_MD5_CTX Md5Ctx;
          HASH HA1;

          osip_MD5Init(&Md5Ctx);
          osip_MD5Update(&Md5Ctx, (unsigned char*)param->gvalue,
                         strlen(param->gvalue));
          osip_MD5Final(HA1, &Md5Ctx);
          CvtHex(HA1, hashstring);
       }
    }


    if ('\0' == hashstring[0])
    {
       /* calculate MD5 hash */
       osip_MD5_CTX Md5Ctx;
       HASH HA1;
       char *tmp;

       osip_MD5Init(&Md5Ctx);

       /* topmost via */
       osip_via_to_str(via, &tmp);
       if (tmp)
       {
          osip_MD5Update(&Md5Ctx, (unsigned char*)tmp, strlen(tmp));
          osip_free(tmp);
       }

       /* Tag in To header */
       osip_to_get_tag(sipmsg->to, &param);
       if (param && param->gvalue)
       {
          osip_MD5Update(&Md5Ctx, (unsigned char*)param->gvalue,
	                 strlen(param->gvalue));
       }

       /* Tag in From header */
       osip_from_get_tag(sipmsg->from, &param);
       if (param && param->gvalue)
       {
          osip_MD5Update(&Md5Ctx, (unsigned char*)param->gvalue,
	                 strlen(param->gvalue));
       }

       /* Call-ID */
       osip_call_id_t* callid = osip_message_get_call_id(sipmsg);
       osip_call_id_to_str(callid, &tmp);
       if (tmp)
       {
          osip_MD5Update(&Md5Ctx, (unsigned char*)tmp, strlen(tmp));
          osip_free(tmp);
       }

       /* CSeq number (but not method) */
       tmp = osip_cseq_get_number(sipmsg->cseq);
       if (tmp)
       {
          osip_MD5Update(&Md5Ctx, (unsigned char*)tmp, strlen(tmp));
       }

       /* Request URI */
       osip_uri_to_str(sipmsg->req_uri, &tmp);
       if (tmp)
       {
          osip_MD5Update(&Md5Ctx, (unsigned char*)tmp, strlen(tmp));
          osip_free(tmp);
       }

       osip_MD5Final(HA1, &Md5Ctx);
       CvtHex(HA1, hashstring);
    }

    /* include the magic cookie */
    strcpy (branch_id, mcookie);
    strcat (branch_id, hashstring);

    __tre(return) RC_OK;
}

